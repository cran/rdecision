<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Andrew J. Sims" />


<title>A directed graph puzzle (Bodycombe 2020)</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">A directed graph puzzle (Bodycombe
2020)</h1>
<h3 class="subtitle">Burger run</h3>
<h4 class="author">Andrew J. Sims</h4>
<h4 class="date">18th June 2020</h4>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This puzzle was published in <em>New Scientist</em> in June 2020<span class="citation"><sup>1</sup></span>. It is a practical example of a
problem in graph theory. This vignette explains how the puzzle can be
solved with <code>redecison</code>.</p>
</div>
<div id="the-puzzle" class="section level1">
<h1>The puzzle</h1>
<p>Three friends agree to drive from A to B via the shortest road
possible (driving down or right at all times). They are hungry, so also
want to drive through a Big Burger restaurant, marked in red. They are
arguing about how many shortest routes will pass through exactly one Big
Burger. Xenia: “I reckon there are 10.” Yolanda: “I’d say more like 20.”
Zara: “No you’re both wrong, I bet there are more than 50.” Who is
right, or closest to right?</p>
<p><img src="data:image/png;base64,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xmEHQN8z0DjsAOh7BhqHHQB9z0DjsAOg7xloHHYA9D0DjcMOgL5noHHYAdD3DDQOOwD6noHGYQdA3zPQOOwA6HsGGocdAH3PQOOwA6DvGWgcdgD0PQONww6AvmegcdgB0PcMNA47APqegcZhB0DfM9A47ADoewYahx0Afc9A47ADoO8ZaBx2APS9k8s+T1YuxjHQSXunl4GerlyMY6CT9s7Pjo/PzlcuxjFQ99DU+cIPNm0vTp0v/GDT9uLU+cIPNm0vTp0v/GDT9uLU+cIPNm0vTp0v/GDT9uLU+cIPNm0vTp0v/GDT9uLU+cIPNm0vTp0v/GBX987P7t65IXev/iuS/njj1PnCD3Z17/Smeb7lzRz0xxunzreK228n0NtZp70veEPqfKsw0Iemzhf+kudL/GLqfOEH85ekxdT5wg82bS9OnS/8YNP24tT5wg82bS9OnS/8YNP24tT5wg82bS9OnS/8YNP24tT5wg82bS9OnS/8YNP24tT5wg82bS9OnS/8YNP24tT5LhVe/1Ew9KAMNMzaJ3j9h2nRgzLQMGuf4PUfR0gPykDDrH2C77+BaOUiPSgDDWOgrL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vgaK2otT52ugqL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vgaK2otT52ugqL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vgaK2otT52ugqL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vgaK2otT52ugqL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vgaK2otT52ugqL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vgaK2otT52ugqL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vgaK2otT52ugqL04db4GitqLU+droKi9OHW+Borai1Pna6CovTh1vkuFTy77PFm5SA/KQMOsfYJPLwM9XblID8pAw6x9gs/Pjo/Pzlcu0oMy0DD0g03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg2X3zs/u3rkhd6/+K9dAw3QFtXrv9KZ5vuXNMAYaZhvN7bcT6O2rG3tf8IbU+Y7GQPF0vSSv3vMlHk9XUKv3/CUJT1dQ//97cep84Qebthenzhd+sGl7cep84Qebthenzhd+sGl7cep84Qebthenzhd+sGl7cep84Qebthenzhd+sGl7cep84Qebthenzhd9sHkfpROnzhd9sHkfRhanzhd9sHkf5xinzhd9sPtvIFq5yH68B6DOF30wA11OnS/6YAa6nDpf9MEMdDl1vuiDGehy6nzRBzPQ5dT5og9moMup80UfzECXU+eLPpiBLqfOF30wA11OnS/6YAa6nDpf9MEMdDl1vuiDGehy6nzRBzPQ5dT5og9moMup80UfzECXU+eLPpiBLqfOF30wA11OnS/6YAa6nDpf9MEMdDl1vuiDGehy6nzRBzPQ5dT5og9moMup80UfzECXU+eLPpiBLqfOF30wA11OnS/6YAa6nDpf9MEMdDl1vuiDGehy6nzRBzPQ5dT5og9moMup80UfzECXU+eLPpiBLqfOF30wA11OnS/6YAa6nDpf9MEMdDl1vuiDGehy6nzRBzPQ5dT5og9moMup80UfzECXU+eLPpiBLqfOF30wA11OnS/6YAa6nDpf9MEMdDl1vuiDGehy6nzRBzPQ5dT5og9moMup80UfzECXU+eLPtjJZZ8nKxfZj/cA1PmiD3Z6GejpykX24z0Adb7og52fHR+fna9cZD/eA1DnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnCz/YtL04db7wg03bi1PnKw/J3he8IW2+t/a+bzu39r7gDWkLVB6eo3ulvvfJn+8tch0MdB5H25efe+7Zpx7fXtzb5BoY6DyOtt9efvnjYx/d2+QaGOg83gz04sl3/Wtnk2tgoPN4EOiHP7WzyHUw0HncC/SNPz/76E/2NrkGBjqPozf/4vT83iLXwUDnce+3+Oee+fj2tD+DCpAHP4N+Y3t5Z5NrYKDzeBDo77Zv72xyDQx0Hg8C/f32nZ1NroGBzuNBoN/cXtrZ5BoY6DyOtq8eHR09++ntE2/srfK/MdB53P8z0yMfeuaVvU2ugYEKGgMVNAYqaAxU0BiooDFQQWOggsZABY2BChoDFTQGKmgMVNAYqKAxUEFjoILGQAWNgQoaAxU0BipoDFTQGKigMVBBY6CCxkAFjYEKGgMVNAYqaAxU0BiooDFQQWOggsZABY2BChoDFTQGKmgMVNAYqKAxUEFjoILGQAWNgQoaAxU0BipoDFTQGKigMVBBY6CCxkAFjYEKGgMVNAYqaAxU0BiooDFQQWOggsZABY2BChoDFTQGKmgMVNAYqKAxUEFjoILGQAWNgQqafwOQNoku/Sub1gAAAABJRU5ErkJggg==" style="display: block; margin: auto;" /></p>
</div>
<div id="constructing-the-graph" class="section level1">
<h1>Constructing the graph</h1>
<p>The grid has 25 nodes and 40 edges (20 horizontal and 20 vertical).
These form a directed graph because it is allowed to drive down or right
only. Seven of the edges are defined as “Big Burger” edges. Because it
is not possible to find a path from any node which revisits that node,
the graph is acyclic (a directed acyclic graph, DAG).</p>
<p>Although it possible to construct the graph by creating 25 node
objects explicitly, it is more compact to create a list of vertices in a
loop construct. Indices <span class="math inline">\(i = [1 ..
5]\)</span> and <span class="math inline">\(j = [1 .. 5]\)</span> are
used to identify grid intersections in the vertical and horizontal
directions respectively. Each node is labelled as <span class="math inline">\(N_{i,j}\)</span> and the index of node <span class="math inline">\(N_{i,j}\)</span> in the list is <span class="math inline">\(5(i-1)+j\)</span>.</p>
<p>Similarly, the 40 edges (arrows) are constructed more compactly in a
list, with horizontal edges being labelled <span class="math inline">\(H_{i,j}\)</span> (the horizontal edge joining node
<span class="math inline">\(N_{i,j}\)</span> to node <span class="math inline">\(N_{i,j+1}\)</span>) and the vertical edges
similarly as <span class="math inline">\(V_{i,j}\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create vertices</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>V <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> 1L <span class="sc">:</span> 5L) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> 1L <span class="sc">:</span> 5L) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    V <span class="ot">&lt;-</span> <span class="fu">c</span>(V, Node<span class="sc">$</span><span class="fu">new</span>(<span class="fu">paste0</span>(<span class="st">&quot;N&quot;</span>, i, j)))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># create edges</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>E <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> 1L <span class="sc">:</span> 5L) {</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> 1L <span class="sc">:</span> 4L) {</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> Arrow<span class="sc">$</span><span class="fu">new</span>(</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      V[[5L <span class="sc">*</span> (i <span class="sc">-</span> 1L) <span class="sc">+</span> j]], V[[5L <span class="sc">*</span> (i <span class="sc">-</span> 1L) <span class="sc">+</span> j <span class="sc">+</span> 1L]], <span class="fu">paste0</span>(<span class="st">&quot;H&quot;</span>, i, j)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    E <span class="ot">&lt;-</span> <span class="fu">c</span>(E, a)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> 1L <span class="sc">:</span> 4L) {</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> 1L <span class="sc">:</span> 5L) {</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> Arrow<span class="sc">$</span><span class="fu">new</span>(</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      V[[5L <span class="sc">*</span> (i <span class="sc">-</span> 1L) <span class="sc">+</span> j]], V[[5L <span class="sc">*</span> i <span class="sc">+</span> j]], <span class="fu">paste0</span>(<span class="st">&quot;V&quot;</span>, i, j)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    E <span class="ot">&lt;-</span> <span class="fu">c</span>(E, a)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># create graph</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>G <span class="ot">&lt;-</span> Digraph<span class="sc">$</span><span class="fu">new</span>(V, E)</span></code></pre></div>
</div>
<div id="finding-the-paths" class="section level1">
<h1>Finding the paths</h1>
<p>Method <code>paths</code> finds all possible paths between any two
nodes, where a <em>path</em> is defined as a sequence of distinct and
adjacent nodes. Because the restaurants are specific edges, each path is
converted to a <em>walk</em>, which is a path defined as sequence of
connected, non-repeating edges.</p>
<p>In this case, the number of restaurants traversed by each path is
counted by comparing the label associated with each edge in each path
with the labels of the edges which contain a restaurant.</p>
<p>Note that although we cannot guarantee that node A is saved
<em>within</em> the graph at index 1 and node B is saved at index 25, we
do know that A and B are saved at indices 1 and 25 in the local list
<code>V</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get all paths from A to B</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>A <span class="ot">&lt;-</span> V[[1L]]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> V[[25L]]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> G<span class="sc">$</span><span class="fu">paths</span>(A, B)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># convert paths to walks</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>W <span class="ot">&lt;-</span> <span class="fu">lapply</span>(P, <span class="cf">function</span>(p) G<span class="sc">$</span><span class="fu">walk</span>(p))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># count and tabulate how many special edges each walk traverses</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>BB <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;V11&quot;</span>, <span class="st">&quot;H22&quot;</span>, <span class="st">&quot;V25&quot;</span>, <span class="st">&quot;H33&quot;</span>, <span class="st">&quot;V32&quot;</span>, <span class="st">&quot;H44&quot;</span>, <span class="st">&quot;V43&quot;</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>nw <span class="ot">&lt;-</span> <span class="fu">vapply</span>(W, <span class="at">FUN.VALUE =</span> 1L, <span class="at">FUN =</span> <span class="cf">function</span>(w) {</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  lv <span class="ot">&lt;-</span> <span class="fu">vapply</span>(w, <span class="at">FUN.VALUE =</span> <span class="cn">TRUE</span>, <span class="at">FUN =</span> <span class="cf">function</span>(e) e<span class="sc">$</span><span class="fu">label</span>() <span class="sc">%in%</span> BB) </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">sum</span>(lv))</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># tabulate </span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>ct <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">table</span>(nw))</span></code></pre></div>
</div>
<div id="solution-found-by-rdecision" class="section level1">
<h1>Solution found by <code>rdecision</code></h1>
<p>The number of paths which pass through exactly one Big Burger is 23.
In total there are 70 paths from A to B, with the number of restaurants
<span class="math inline">\(n\)</span>, traversed by each path as
follows:</p>
<table>
<thead>
<tr class="header">
<th align="left">n</th>
<th align="right">frequency</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="right">6</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="right">23</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="right">27</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
</div>
<div id="provided-solution" class="section level1">
<h1>Provided solution</h1>
<p>Yolanda’s estimate is closest - there are 23 shortest routes from A
to B that pass through exactly one Big Burger. One way to solve this
kind of puzzle is to systematically work from A and keep track of how
many ways there are of reaching each point. With this problem, you
should keep a separate count of how many ways there are of reaching each
point after (a) zero or (b) one Big Burger visits. For line segments
that contain a Big Burger, (b) becomes equal to (a) then becomes equal
to 0 with the old value for (b) effectively discarded.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body" line-spacing="2">
<div id="ref-bodycombe2020" class="csl-entry">
<div class="csl-left-margin">1. </div><div class="csl-right-inline">Bodycombe, D. Burger run. <em>New
Scientist</em> <strong>246,</strong> 54 (2020).</div>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
